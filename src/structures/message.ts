import {ISO8601, Snowflake} from "./generics.ts";
import {Attachment} from "./attachment.ts";
import {Mention as ChannelMention} from "./channel.ts";
import {Embed} from "./embed.ts";
import {GuildMember} from "./guildMember.ts";
import {Reaction} from "./reaction.ts";
import {User} from "./user.ts";
import {Emoji} from "./emoji.ts";


/** a message type */
export enum Type {
	DEFAULT = 0,
	RECIPIENT_ADD = 1,
	RECIPIENT_REMOVE = 2,
	CALL = 3,
	CHANNEL_NAME_CHANGE = 4,
	CHANNEL_ICON_CHANGE = 5,
	CHANNEL_PINNED_MESSAGE = 6,
	GUILD_MEMBER_JOIN = 7,
	USER_PREMIUM_GUILD_SUBSCRIPTION = 8,
	USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_1 = 9,
	USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_2 = 10,
	USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_3 = 11,
	CHANNEL_FOLLOW_ADD = 12,
	GUILD_DISCOVERY_DISQUALIFIED = 14,
	GUILD_DISCOVERY_REQUALIFIED = 15
}

/** allowed mentions */
export enum AllowedMentionType {
	/** Controls role mentions */
	ROLE_MENTIONS = "roles",
	/** Controls user mentions */
	USER_MENTIONS = "users",
	/** Controls @everyone and @here mentions */
	EVERYONE_MENTIONS = "everyone"
}


/** a message activity type */
export enum ActivityType {
	JOIN = 1,
	SPECTATE = 2,
	LISTEN = 3,
	JOIN_REQUEST = 5
}

/** message flags, which describe extra features of a message */
export enum Flags {
	/** this message has been published to subscribed channels (via Channel Following) */
	CROSSPOSTED = 1 << 0,
	/** this message originated from a message in another channel (via Channel Following) */
	IS_CROSSPOST = 1 << 1,
	/** do not include any embeds when serializing this message */
	SUPPRESS_EMBEDS = 1 << 2,
	/** the source message for this crosspost has been deleted (via Channel Following) */
	SOURCE_MESSAGE_DELETED = 1 << 3,
	/** this message came from the urgent message system */
	URGENT = 1 << 4
}


/** a message activity */
export interface Activity {
	/** type of message activity */
	type: ActivityType;
	/** party_id from a Rich Presence event */
	party_id?: string;
}

/** a message application */
export interface Application {
	/** id of the application */
	id: Snowflake;
	/** id of the embed's image asset */
	cover_image?: string;
	/** application's description */
	description: string;
	/** id of the application's icon */
	icon: string | null;
	/** name of the application */
	name: string;
}

/** allowed mentions allows for more granular control over mentions without various hacks to the message content. this will always validate against message content to avoid phantom pings (e.g. to ping everyone, you must still have `@everyone` in the message content), and check against user/bot permissions */
export interface AllowedMentions {
	/** An array of allowed mention types to parse from the content. */
	parse: AllowedMentionType[];
	/** Array of role_ids to mention (Max size of 100) */
	roles: Snowflake[];
	/** Array of user_ids to mention (Max size of 100) */
	users: Snowflake[];
}

/** a message reference */
export interface Reference {
	/** id of the originating message */
	message_id?: Snowflake;
	/** id of the originating message's channel */
	channel_id: Snowflake;
	/** id of the originating message's guild */
	guild_id?: Snowflake;
}


/** a message */
export interface Message {
	/** id of the message */
	id: Snowflake;
	/** id of the channel the message was sent in */
	channel_id: Snowflake;
	/** id of the guild the message was sent in */
	guild_id?: Snowflake;
	/**
	 * the author of this message.
	 * NOTE: the author object follows the structure of the user object, but is only a valid user in the case where the message is generated by a user or bot user. If the message is generated by a webhook, the author object corresponds to the webhook's id, username, and avatar. You can tell if a message is generated by a webhook by checking for the `webhook_id` on the message object
	 */
	author: User | (Pick<User, "username" | "avatar"> & { webhook_id: Snowflake });
	/**
	 * member properties for this message's author
	 * NOTE: the member object exists in `MESSAGE_CREATE` and `MESSAGE_UPDATE` events from text-based guild channels. This allows bots to obtain real-time member data without requiring bots to store member state in memory
	 */
	member?: Partial<GuildMember>;
	/** contents of the message */
	content: string;
	/** when this message was sent */
	timestamp: ISO8601;
	/** when this message was edited (or null if never) */
	edited_timestamp: ISO8601 | null;
	/** whether this was a TTS message */
	tts: boolean;
	/** whether this message mentions everyone */
	mention_everyone: boolean;
	/**
	 * users specifically mentioned in the message.
	 * NOTE: the user objects in the mentions array will only have the partial member field present in `MESSAGE_CREATE` and `MESSAGE_UPDATE` events from text-based guild channels
	 */
	mentions: (User & { member: Partial<GuildMember> })[];
	/** roles specifically mentioned in this message */
	mention_roles: Snowflake[];
	/** channels specifically mentioned in this message */
	mention_channels?: ChannelMention[];
	/** any attached files */
	attachments: Attachment[];
	/** any embedded content */
	embeds: Embed[];
	/** reactions to the message */
	reactions?: Reaction[];
	/** used for validating a message was sent */
	nonce?: number | string;
	/** whether this message is pinned */
	pinned: boolean;
	/** if the message is generated by a webhook, this is the webhook's id */
	webhook_id?: Snowflake;
	/** type of message */
	type: Type;
	/** sent with Rich Presence-related chat embeds */
	activity?: Activity;
	/** sent with Rich Presence-related chat embeds */
	application?: Application;
	/** reference data sent with crossposted messages */
	message_reference?: Reference;
	/** message flags `OR`d together, describes extra features of the message */
	flags?: number;
}


export interface Create extends Partial<Pick<Message, "content" | "nonce" | "tts">> {
	/** the contents of the file being sent */
	file?: File;
	/** embedded `rich` content */
	embed?: Embed;
	/** JSON encoded body of any additional request fields. */
	payload_json?: string;
	/** object	allowed mentions for a message */
	allowed_mentions?: AllowedMentions;
}

export type Edit = Partial<Pick<Message, "content" | "flags"> & Pick<Create, "embed">>;

export type DeleteEvent = Pick<Message, "id" | "channel_id" | "guild_id">;

export interface ReactionAddEvent {
	user_id: Snowflake;
	channel_id: Snowflake;
	message_id: Snowflake;
	guild_id?: Snowflake;
	member?: GuildMember;
	emoji: Partial<Emoji>;
}

export type ReactionRemoveEvent = Omit<ReactionAddEvent, "member">

export type ReactionRemoveAllEvent = Omit<ReactionRemoveEvent, "emoji" | "user_id">;

export type ReactionRemoveEmojiEvent = Omit<ReactionRemoveEvent, "user_id">;
